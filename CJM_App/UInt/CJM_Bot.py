# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'C:\Users\dminovoz\Desktop\PythonProgs\Project_default_Env\Project 1\TestBuilds\GUI\1.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from openai import OpenAI
from openpyxl import Workbook
import pandas as pd
import time
import os
import openpyxl
from openai import OpenAI
from datetime import datetime
import sys
from openpyxl import load_workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
import shutil
import logging
from flask import session, current_app

logging.basicConfig(level=logging.INFO)

client = OpenAI(api_key="sk-proj-")

value_assistant = "asst_"


###################################################### Начало основного кода #################################################################

def convert_to_txt(file_path):
    print(file_path)
    """
    Convert a file to a text file (.txt) using pandas.

    Args:
        file_path (str): Path to the input file.

    Returns:
        str: Path to the output text file, or None if an error occurs.
    """
    try:
        file_extension = file_path.split('.')[-1]
        if file_extension == 'xlsx':
            df = pd.read_excel(file_path)
            print(file_extension)
        elif file_extension == 'csv':
            df = pd.read_csv(file_path, encoding='cp1251', delimiter=';', on_bad_lines='skip')  # Укажите нужную кодировку, разделитель и поведение при ошибках
            print(file_extension)
        else:
            raise ValueError("Invalid file extension. Only xlsx and csv files are supported.")
    
        txt_file_path = file_path.replace(f".{file_extension}", ".txt")
        df.to_csv(txt_file_path, index=False, header=True)
        print(txt_file_path)
        return txt_file_path
    except Exception as e:
        # Log error and return None
        print(f"Error converting file: {e}")
        return None

def file_convert(file_path):
    try:
        # Конвертация файла в формат .txt
        txt_file_path = convert_to_txt(file_path)

        # Проверка размера файла (в килобайтах)
        file_size_txt= os.path.getsize(txt_file_path) / 1024  # Перевод размера в килобайты
        print(file_size_txt)
        file_size_kb = os.path.getsize(file_path) / 1024  # Перевод размера в килобайты
        print(file_size_kb)
        max_size_kb = 5000 # Максимальный допустимый размер файла в килобайтах (3 мегабайта)

        if file_size_kb > max_size_kb:
            print("Размер файла превышает максимально допустимый размер.")
            return None
            
        else:
            print(f"Файл успешно сконвертирован в формат .txt: {txt_file_path}")
            return txt_file_path
    except FileNotFoundError:
        print("Файл не найден. Пожалуйста, укажите корректный путь к файлу.")
        return None
        
# Функция для загрузки файла
def file_upload(txt_file_path):
    try:
        # Открываем файл в бинарном режиме и загружаем его в ассистента
        with open(txt_file_path, "rb") as file:
            response = client.files.create(
                file=file,
                purpose="assistants"  # Указываем цель
            )
        file_id = response.id
        print(f"Файл успешно загружен с ID: {file_id}")
        return file_id
    except FileNotFoundError:
        print("Файл не найден. Пожалуйста, укажите корректный путь к файлу.")

#############################################################################################################################################
def get_files():
    # """ Получение списка файлов через API """
    try:
        file_list = client.files.list()
        print(file_list.data)  # Вывод данных для отладки
        return file_list.data
    except Exception as e:
        print(f"Не удалось получить список файлов: {e}")
        return []
    
def delete_file_api(file_id):
    # """ Удаление файла по ID через API """
    try:
        client.files.delete(file_id)
        print(f"Файл {file_id} успешно удален")
    except Exception as e:
        print(f"Ошибка при удалении файла {file_id}: {e}")

def delete_file(file_path):
    if os.path.exists(file_path):
        os.remove(file_path)
        print("Файл успешно удален")
    else:
        print("Файл не существует")


# Вызов функции для создания сообщения в треде
def update_thread_message(thread_id, user_input):
    # Например:
    thread_message = client.beta.threads.messages.create(
                                thread_id,
                                role="user",
                                content=user_input,
                                                                                )
    print("Сообщение успешно отправлено в поток:", thread_message)


def check_thread_status(thread_id, run_id_PEREMEN):
    while True:
        # Получение информации о текущем запуске треда
        run = client.beta.threads.runs.retrieve(
            thread_id=thread_id,
            run_id=run_id_PEREMEN
                                                )
        thread_status = run.status
        print("Статус треда:", thread_status)
        
        if thread_status == 'completed':
            return run  # Возвращаем объект run, когда статус станет "completed"
        
        time.sleep(0.33)  # Ждем 5 секунд перед следующей проверкой 

                 
# Вызов функции обновления tred с message
def start_thread_run(thread_id, assistant_id):
    # Например:
    run = client.beta.threads.runs.create(
                                thread_id=thread_id,
                                assistant_id=value_assistant)
    #print("Тред успешно запущен:", run)
    run_id_PEREMEN = run.id
    thread_id = run.thread_id
    thread_status = run.status
    print("Статус обработки треда:", thread_status)
    return run_id_PEREMEN

def create_excel_table_dynamic(stages, options):
    wb = Workbook()
    ws = wb.active

    # Форматирование для заголовков столбцов
    column_header_font = Font(bold=True)
    column_header_fill = PatternFill(start_color="F2EADF", end_color="F2EADF", fill_type="solid")

    # Форматирование для заголовков строк
    row_header_font = Font(italic=True)
    row_header_fill = PatternFill(start_color="EEEEEE", end_color="EEEEEE", fill_type="solid")

    # Настройка для ячеек с объемным текстом
    text_alignment = Alignment(wrap_text=True, vertical='top')

    # Настройка границ ячеек
    thin_border = Border(left=Side(style='thin'), 
                         right=Side(style='thin'), 
                         top=Side(style='thin'), 
                         bottom=Side(style='thin'))

    thick_border = Border(left=Side(style='thick'), 
                          right=Side(style='thick'), 
                          top=Side(style='thick'), 
                          bottom=Side(style='thick'))

    # Установка заголовков колонок на основе выбранных этапов
    column_headers = ['Опции/Этап'] + stages
    for col_num, header in enumerate(column_headers, 1):
        cell = ws.cell(row=1, column=col_num, value=header)
        cell.font = column_header_font
        cell.fill = column_header_fill
        cell.alignment = text_alignment
        cell.border = thick_border  # Внешние границы заголовков столбцов

    # Установка заголовков строк на основе выбранных опций
    for row_num, header in enumerate(options, 2):
        cell = ws.cell(row=row_num, column=1, value=header)
        cell.font = row_header_font
        cell.fill = row_header_fill
        cell.alignment = text_alignment
        cell.border = thin_border

    # Автоподстройка ширины колонки A
    max_length = max([len(str(header)) for header in column_headers]) + 2
    ws.column_dimensions['A'].width = max_length

    # Автоподстройка ширины колонок для содержимого
    for col in ws.iter_cols(min_col=2, max_col=len(stages) + 1):  # Изменяем ширину только для столбцов с 2-го и далее
        max_length = 0
        column = col[0].column_letter
        for cell in col:
            try:
                if len(str(cell.value)) > max_length:
                    max_length = len(str(cell.value))
            except:
                pass
        adjusted_width = (max_length + 2)  # Увеличенная ширина столбца
        ws.column_dimensions[column].width = adjusted_width

    # Автоподстройка высоты строк для содержимого
    for row in ws.iter_rows(min_row=2, max_row=len(options) + 1, min_col=2, max_col=len(stages) + 1):
        for cell in row:
            cell.alignment = text_alignment  # Включаем перенос текста и верхнее выравнивание во всех ячейках данных
            cell.border = thin_border  # Границы данных ячеек

    output_dir = os.path.join(current_app.root_path, 'output')
    if os.path.exists(output_dir):
        shutil.rmtree(output_dir)
    os.makedirs(output_dir, exist_ok=True)

    # Получение текущей даты и времени
    current_datetime = datetime.now()
    # Преобразование даты и времени в строку с определенным форматом
    datetime_str = current_datetime.strftime("%Y-%m-%d_%H-%M-%S")
    # Создание имени файла с уникальным идентификатором
    file_name = f"Ответ_CJM_{datetime_str}.xlsx"
    # Путь к файлу для сохранения на сервере
    xlsx_path = os.path.join(output_dir, file_name)

    wb.save(xlsx_path)
    return xlsx_path

#create_excel_table_dynamic(stages, options)

# Функция для добавления данных в Excel
def write_to_excel(xlsx_path, data, row, col):
    # Загружаем книгу Excel
    Workbook = load_workbook(xlsx_path)
    # Активируем рабочий лист
    w_sheet = Workbook.active
    # Записываем данные
    # Data can be assigned directly to cells
    w_sheet.cell(row=row, column=col, value=data)
    # Сохраняем изменения
    Workbook.save(xlsx_path)
    Workbook.close()

# Вызов функции для того, чтобы доставать последний message
def process_thread_messages(thread_id):
    # Достаем ответы из треда
    thread_messages = client.beta.threads.messages.list(thread_id=thread_id)

    # После записи в эксель, можно удалить тред
    for answer in thread_messages.data:
        print("Полученный ответ:" + answer.content[0].text.value + "\n")
        answer = answer.content[0].text.value
        # delete = client.beta.threads.delete(thread_id)            # Возможно удалять будем в другом месте и вообще по-другому
        break
    return answer


##########################################################################################################################

def two_thread_message_deletion(thread_id):
    try:
        # Retrieve a list of all messages in the thread
        thread_messages_response = client.beta.threads.messages.list(thread_id)

        # Check if there are at least two messages in the thread
        if len(thread_messages_response.data) >= 2:
            # Extract the IDs of the last two messages
            thread_messages = list(thread_messages_response)
            last_message_id = thread_messages[-2].id
            second_last_message_id = thread_messages[-3].id
            
            last_message_content = thread_messages[-2].content
            second_last_message_content = thread_messages[-3].content
           # third_last_message_content = thread_messages[-3].content
           # forth_last_message_content = thread_messages[-4].content
            # Delete the last message
            deleted_last_message = client.beta.threads.messages.delete(
                message_id=last_message_id,
                thread_id=thread_id,
            )
            print(f"Deleted last message with ID {last_message_id}")
            print("Last message content:", last_message_content)

            # Delete the second-to-last message
            deleted_second_last_message = client.beta.threads.messages.delete(
                message_id=second_last_message_id,
                thread_id=thread_id,
            )
            print(f"Deleted second-to-last message with ID {second_last_message_id}")
            print("Second last message content:", second_last_message_content)
            #print("Third last message content:", third_last_message_content)
            #print("Fourth last message content:", forth_last_message_content)
        else:
            print("Not enough messages in the thread to delete.")
    except Exception as e:
        print(f"Error deleting messages: {e}")

##########################################################################################################################
# Получаем путь к текущему каталогу

# Основная логика остается без изменений до вызова create_excel_table, за исключением генерации таблицы и передач динамических стадий и опций
def main(input1, input2, stages, options, file=None):
    logging.info("Starting main function")
    print(file)
    value_Categ = input1 
    value_Client = input2
    file_path = None

    # Проверяем и создаем каталог uploads, если его нет
    upload_dir = "uploads"
    if os.path.exists(upload_dir):
        shutil.rmtree(upload_dir)
        os.makedirs(upload_dir)
    else: 
        os.makedirs(upload_dir)

    promt_Categ = "Мы анализируем товары в категории:" + " " + value_Categ + "."
    promt_Client = "Бренд нашего заказчика:" + " " + value_Client + "."
    
    # Определение значений этапов и опций
    stage_prompts = {
        "Возникновение потребности в товаре":"Проанализируй поведение потребителя нашего клиента в контексте этапа 'первого Возникновения потребности в товаре'.",
        "Принятие решения о покупке":"Проанализируй поведение потребителя нашего клиента в контексте этапа 'Принятия решения о покупке'.",
        "Совершение покупки":"Проанализируй поведение потребителя нашего клиента в контексте этапа 'Совершения покупки'.",
        "Возникновения лояльности к бренду или совершения повторной покупки":"Проанализируй поведение потребителя нашего клиента в контексте этапа 'Возникновения лояльности к бренду или совершения повторной покупки'."
    }

    option_prompts = {
        "Шаги в рамках этапов":"Определи конкретные действия, которые выполняет потребитель в рамках упомянутого этапа.",
        "Точки контакта":"Выяви места, каналы и интерфейсы соприкосновения потребителя с продуктом или сервисом.",
        "Драйверы":"Определи факторы, подталкивающие потребителя на совершение покупки / использование продукта / сервиса.",
        "Барьеры":"Определи барьеры, которые останавливают потребителя от покупки / использования продукта / сервиса.",
        "Бренды":"Выдели все бренды, упоминаемые в файле. Постарайся упомянуть всех ключевых игроков из файла.",
        "Цитаты":"Приведи примеры в виде цитат, подтверждающих выводы по каждой из следующих опций: Шаги в рамках этапов, Точки контакта, Драйверы, Барьеры"
    }

    logging.info("Completed stage 1")


    empty_thread = client.beta.threads.create()
    thread_id = empty_thread.id
    print("Параметры запущенного треда:", thread_id)
    # Проверяем загрузил ли пользователь файл, если да обрабатываем и подгружаем
    if file:
        save_path = os.path.join(upload_dir, file.filename)
        file.save(save_path)
        file_path = save_path
        txt_file_path = file_convert(file_path)
        file_content = file_upload(txt_file_path)
        delete_file(txt_file_path)  
        print("Удаленный файл:", txt_file_path)
        # Проверяем есть ли подгруженный в опен Аи файл, если нет запускаем анализ без него
        if file_content != None:
            thread_message = client.beta.threads.messages.create(
                thread_id,
                role="user",
                content="Привет, я отправлю тебе файл на анализ. Следующим сообщением я отправлю тебе инструкцию к работе с файлом." + " " + promt_Categ + " " + promt_Client + ". В своем ответе ни в коем случае не используй ссылки на цитаты и не указывай источники, а добавляй цитаты полностью.",
                attachments=[{"file_id": file_content, "tools": [{"type": "file_search"}]}]
            )
        else:
            thread_message = client.beta.threads.messages.create(
                thread_id,
                role="user",
                content="Привет, я отправляю тебе текстовые данные на анализ. Следующим сообщением я отправлю тебе инструкцию к работе с этими данными." + " " + promt_Categ + " " + promt_Client + ". В своем ответе ни в коем случае не используй ссылки на цитаты и не указывай источники, а добавляй цитаты полностью."
            )
    xlsx_path = create_excel_table_dynamic(stages, options)
    print(xlsx_path)

    logging.info("Completed stage 2")

    for stage in stages:
        if stage in stage_prompts:
            stage_prompt = stage_prompts[stage]
            stage_index = stages.index(stage) + 2  # Сдвиг на 2, так как колонка 1 занята заголовками строк

            for option in options:
                if option in option_prompts:
                    option_prompt = option_prompts[option]
                    option_index = options.index(option) + 2  # Сдвиг на 2, так как строка 1 занята заголовками колонок

                    user_input = f"{stage_prompt} {option_prompt}"
                    upd = update_thread_message(thread_id, user_input)
                    print(upd)

                    run_id_PEREMEN = start_thread_run(thread_id, value_assistant)
                    print(f"ID запуска возвращенный из функции: {run_id_PEREMEN}")

                    run = check_thread_status(thread_id, run_id_PEREMEN)
                    print(f"Финальный статус обработки треда: {run.status}")

                    assistant_message = process_thread_messages(thread_id)
                    print(stage)
                    print(option)

                    # Запись в Excel с учетом обновленных значений
                    write_to_excel(xlsx_path, assistant_message, option_index, stage_index)
                    
                    two_thread_message_deletion(thread_id)

    logging.info("Finished main function")
    
    files = get_files()
    if files:
        for file_info in files:
            file_id = file_info.id  # Идентификатор файла
            print(file_info.id)
            delete_file_api(file_id)

    # Возвращаем путь к сгенерированному файлу
    return xlsx_path